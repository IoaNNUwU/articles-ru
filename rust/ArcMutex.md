 # **Arc<Mutex\<T>>**

Приветствую всех любителей языка Rust. Сегодня я бы хотел рассказать о таком примитиве синхронизации как `Arc<Mutex<T>>`. Он используется при работе с несколькими потоками и применяется для обеспечения доступа к одному и тому же участку памяти из нескольких потоков.

# **Arc<Mutex\<T>>**
- **A**tomic **R**eference **C**ounter
- **Mut**ually **Ex**clusive flag
- type **T**

Тут в комбинации используется **Arc** - Атомарный счётчик ссылок, а также **Mutex** - флаг уникального доступа.

Из названия понятно что именно **Mutex** отвечает за эксклюзивный доступ к памяти, тогда почему же он всегда используется вместе с атомарным счётчиком?

---
<!-- ignore -->
```rust
struct User { id: i32 }

fn main() {
    let user = User { id: 136 };
    let user_ref: &User = &user;

    for _ in 1..10 {
        std::thread::spawn(move || {
            println!("{}", (*user_ref).id);
        });
    };
}
```

Чтобы понять это, следует попробовать сделать что-то подобное. Здесь мы создаём пользователя и берём ссылку на него. Дальше в цикле создаём 10 потоков, каждый из которых копируют эту ссылку. При этом она всё ещё указывает на того же юзера. Дальше каждый поток читает значение по этой ссылке и выводит его на экран.

Ключевое слово `move` используется для того чтобы сказать компилятору, чтоб замыкание должно завладеть ссылкой на юзера. Именно **ссылкой**. В данном случае он просто её скопирует, так как немутабельная ссылка реализует трейт Copy, и в результат перемещения она просто скопируется.

Вроде бы всё логично, однако этот код не компилируется.

---

```rust
struct User { id: i32 }

fn main() {
    let user = User { id: 136 };
    let user_ref: &User = &user;
    //                    ^^^^^
    //                    borrowed value does not
    //                    live long enough

    for _ in 1..10 {
        std::thread::spawn(move || {
            //       ^^^^^
            //       argument requires that `user`
            //       is borrowed for `'static`

            println!("{}", (*user_ref).id);
        });
    };
}
// `user` dropped here while still borrowed
```

Проблема заключается в том что user живёт недостаточно долго, то есть память под него будет освобождена до того, как на него не останется ссылок. Об этом компилятор говорит нам на последней строчке.

Дело в том что по правилам языка Rust, в конце функции `main`, компилятор автоматически вызывает метод `drop` у пользователя. При этом мы не знаем сколько времени займёт создание потоков и не можем гарантировать, что они завершатся быстрее чем, функция `main`. Это значит что вполне возможно, что мы захотим перейти по ссылке на уже очищенную память, что Rust запрещает.

![threads](res/threads.svg)

При этом единственное требование компилятора, это чтобы у любых ссылок, которые мы используем внутри `thread::spawn` был статический лайфтайм. Такой лайфтайм и будет гарантией того что ссылка будет валидной на всём протяжении работы созданного потока. Какие у нас есть способы добиться этого?

# Make it **'static**

```rust
struct User { id: i32 }

fn main() {
    let heap_allocated_user = Box::new(User { id: 136 });
    let user_ref: &'static User = Box::leak(heap_allocated_user);

    for _ in 1..10 {
        std::thread::spawn(move || {
            println!("{}", (*user_ref).id);
        });
    };
}
```

Один из способов добиться `'static` лайфтайма это функция `Box::leak`, которая позволяет получить статическую ссылку на любой объект аллоцированый в куче с помощью `Box::new`. Это происходит благодаря тому, что компилятор забывает о том, что `Box` показывает владение над величиной, а если памятью никто не владеет, она будет очищена при завершении работы программы.

# Don't make it **'static**

```rust
struct User { id: i32 }

fn main() {
    let heap_allocated_user = Box::new(User { id: 136 });
    let user_ref: &'static User = Box::leak(heap_allocated_user); 

    for _ in 1..10 {
        std::thread::spawn(move || {
            println!("{}", (*user_ref).id);
        });
    };
    // heap_allocated_user should be deallocated here
    // as it is no longer in use

    println!("heap_allocated_user was not deallocated at this point");
}
```

Основная проблема такого подхода состоит в том, что память будет очищена только в конце программы. То есть если юзер будет очищен только в конце программы, даже если он используется в начале, он вынужден ждать всё время работы, занимая лишнюю память. А если мы создаём такие ссылки часто, то память в какой-то момент закончится.

# Use **Arc**

```rust
struct User { id: i32 }

use std::sync::Arc;

fn main() {
    let arc_user: Arc<User> = Arc::new(User { id: 136 });

    for _ in 1..10 {
        let user_ref_copy = Arc::clone(&arc_user); 

        std::thread::spawn(move || {
            println!("{}", (*user_ref_copy).id);
        });
    };
}
```

Eсть и ещё один интересный способ добиться того, чтобы все ссылки имели статический лайфтайм - не использовать ссылки! Ведь Arc это некая структура, которая ведёт себя похожим на ссылки образом, но при этом ссылкой не является. Значит компилятор разрешает его использование.

> Arc\<User> можно читать как User с счётчиком ссылок.

Обратите внимание, что `Arc` необходимо копировать в ручную с помощью `Arc::clone`. Это необходимо делать до `thread::spawn`, потому что если мы попытаемся скопировать Arc внутри `thread::spawn`, мы будем пытаться его скопировать в другом потоке, то есть мы сначала скопируем **обычную** ссылку на `Arc\<User>` в другой поток и только потом с помощью неё будем копировать `Arc`. То есть мы вернулись к первому примеру, ведь сначала мы используем ссылку на `Arc`.

# ⚙️ **Arc**

```rust
struct User { id: i32 }

use std::sync::Arc;

fn main() {
    let arc_user = Arc::new(User { id: 136 }); // 1

    for _ in 1..10 {
        let user_ref_copy: Arc<User> = Arc::clone(&arc_user); // +1 x10 

        std::thread::spawn(move || { // user_ref_copy moved in closure
            println!("{}", (*user_ref_copy).id);
        }); // -1 x10
    };
} // -1
```

Как же работает `Arc`?

Как понятно из названия, это счётчик ссылок. Мы создаём `Arc` с юзером с помощью `Arc::new`. `Arc` выступает контейнером для величины внутри. Когда мы его создаём, счётчик показывает **1**. То есть существует одна копия этого счётчика. Когда мы копируем ссылку на `Arc` с помощью `Arc::clone`, мы получаем ещё один `Arc`, который имеет общий счётчик и общую ссылку на объект внутри, а также предоставляет доступ на чтение к объекту внутри, то есть `Arc` выполняет роль немутабельной ссылки, которую мы пытались использовать раньше. Когда копия `Arc` выходит из скоупа, то есть заканчивается функция или замыкание, например внутри `thread::spawn` компилятор вызывает метод `drop` у `Arc<User>`, который снижает счётчик ссылок на **1**.
Когда последняя копия `Arc` выходит из скоупа, то счётчик ссылок достигает нуля, компилятор вызывает `drop` у последней копии `Arc`. Этот метод очищает память выделенную под юзера и под сам счётчик, если количество активных ссылок равно **0**.

При этом не важна какая копия `Arc` выйдет из скоупа первой, а какая последней. То есть `Arc` будет скопирован 10 раз в цикле, после чего дропнут оригинальный `Arc` в конце функции `main`, хотя нам может показаться что он должен выйти из скоупа последним, он ведь ниже всего. Однако, мы не знаем сколько времени нужно на создание потоков, и скорее всего они будут работать ещё после того как функция `main` завершится.
То есть юзер будет очищен одним из созданных потоков, который завершится последним.

# **Arc\<T>**

<!-- ignore -->
```rust
let user_ref: Arc<User> = Arc::clone(&user);
```

`Arc` позволяет нам копировать ссылку на объект в разные потоки путём `Arc::clone`, при этом мы по этой ссылке можем только читать данные, но не изменять их. Память под объект и счётчик будет очищена когда последняя копия `Arc` выйдет из скоупа.
То есть `Arc` позволяет нам убедиться в том, что объект не будет удалён раньше, чем это нужно, а также удалить объект сразу после того как ссылок на него не осталось.

---

<!-- ignore -->
```rust
struct User { id: i32 }

fn main() {
    let heap_allocated_user = Box::new(User { id: 136 });
    let user_ref: &'static mut User = Box::leak(heap_allocated_user);

    for _ in 1..10 {
        std::thread::spawn(move || {
            (*user_ref).id += 1;
            println!("{}", (*user_ref).id);
        });
    };
}
```

Вернёмся к более простому примеру.

Мы получаем статическую ссылку на юзера, которая никогда не очистится, передаём её в другой поток, а затем пробуем изменить **id**. Для этого ссылка должна быть изменяемой, о чем говорит ключевое слово **mut**.

---

<!-- ignore -->
```rust
struct User { id: i32 }

fn main() {
    let heap_allocated_user = Box::new(User { id: 136 });
    let user_ref: &'static mut User = Box::leak(heap_allocated_user);
    //  ^^^^^^^^
    //  move occurs because `user_ref` has type `&mut User`,
    //  which does not implement the `Copy` trait

    for _ in 1..10 {
        std::thread::spawn(move || {
            //             ^^^^
            //            `user_ref` moved into closure here,
            //             in previous iteration of loop

            (*user_ref).id += 1;
            println!("{}", (*user_ref).id);
        });
    };
}
```

Но данный код не компилируется. Дело в том что мутабельную ссылку нельзя скопировать в другой поток, как это было с немутабельной. Это происходит потому что по правилам языка Rust одновременно не может существовать более одной мутабельной ссылки на один объект, поэтому обычная ссылка `&` реализует трейт `Copy`, но мутабельная `&mut` нет.

То есть у нас нет абсолютно никакой возможности передать мутабельную ссылку на одну и ту же область памяти другому потоку. Такое действие запрещено правилами языка Rust.

---

```rust
struct User { id: i32 }

fn main() {
    let heap_allocated_user = Box::new(User { id: 136 });
    let user_ref: &'static User = Box::leak(heap_allocated_user);

    for _ in 1..10 {
        std::thread::spawn(move || {
            // (*user_ref).id += 1;
            println!("{}", (*user_ref).id);
        });
    };
}
```

Если Rust разрешает нам иметь только несколько обычных немутабельных ссылок на одну и ту же область памяти, нам **придётся** использовать их. И в случае когда мы хотим получить доступ к изменению одной величины из нескольких потоков, нам придётся придумывать способы обойти это ограничение языка. И Rust сам нам предлагает такие способы. Один из них - это как раз `Mutex`.

# Use **Mutex**

```rust
struct User { id: i32 }

use std::sync::{Mutex, MutexGuard};

fn main() {
    let mutex_user = Mutex::new(User { id: 136});
    let heap_allocated_mutex_user = Box::new(mutex_user);

    let mutex_ref: &'static Mutex<User> = Box::leak(heap_allocated_mutex_user);

    for _ in 1..10 {
        std::thread::spawn(move || {

            let mut user: MutexGuard<User> = mutex_ref.lock().unwrap();
            user.id += 1;
            println!("{}", user.id);
        });
    };
}
```

> Mutex\<User> можно читать как мутабельно эксклюзивный юзер.

У `Mutex` не такой простой API, так что давайте по порядку.

Мы создаём `Mutex` с помощью `Mutex::new`. Он выступает контейнером для юзера и даёт доступ к мутабельной ссылке на него особым образом, чтобы добиться что только 1 поток имеет к нему доступ в каждый момент.

Далее мы везде заменяем ссылку на юзера `&User` ссылкой на Mutex юзера `&Mutex<User>`. Простой и немутабельной ссылкой, которую компилятор разрешает.

Далее поток через обычную ссылку на `Mutex`, с помощью метода `lock` может получить доступ к некой структуре `MutexGuard`, через которую осуществляем доступ к юзеру. `MutexGuard<User>` очень похож на мутабельную ссылку на юзера и позволяет с ним делать всё, что позволяет мутабельная ссылка.

Когда мы вызываем метод `lock`, поток блокируется пока не придёт его очередь получить доступ к этой области памяти. Задача `MutexGuard` же состоит в том, чтобы когда он будет дропнут - то есть в конце замыкания внутри метода `thread::spawn` - **разблокировать** поток и позволить **следующему** потоку в очереди получить доступ.

---

```rust
struct User { id: i32 }

use std::sync::{Mutex, MutexGuard};

fn main() {
    let mutex_user = Mutex::new(User { id: 136});
    let heap_allocated_mutex_user = Box::new(mutex_user);

    let mutex_ref: &'static Mutex<User> = Box::leak(heap_allocated_mutex_user);

    for _ in 1..10 {
        std::thread::spawn(move || {
            let mut user: MutexGuard<User> = mutex_ref.lock().unwrap();
            user.id += 1;
            println!("{}", user.id);
        });
    };
    // heap_allocated_mutex_user should be deallocated here
    // as it is no longer in use

    println!("heap_allocated_mutex_user was not deallocated")
}
```

Итак мы поговорили о том, как использовать Mutex со статической ссылкой. Проблема данного подхода в том, что Mutex и юзер будут очищены только в конце работы программы. Как мы уже рассмотрели, эту проблему решает `Arc` - Atomic Reference Counter.

# **Arc<Mutex\<T>>**

```rust
struct User { id: i32 }

use std::sync::{Arc, Mutex, MutexGuard};

fn main() {
    let arc_mutex_user: Arc<Mutex<User>> = Arc::new(Mutex::new(User { id: 136}));

    for _ in 1..10 {
        let mutex_ref_copy = Arc::clone(&arc_mutex_user);

        std::thread::spawn(move || {
            let mut user: MutexGuard<User> = mutex_ref_copy.lock().unwrap();
            user.id += 1;
            println!("{}", user.id);
        });
    };
}
```

`Arc` предоставляет доступ к объекту внутри только по немутабельной ссылке. Однако для `Mutex` это не является проблемой потому что он позволяет изменять объект внутри себя по такой же обычной немутабельной ссылке, поэтому `Arc` и `Mutex` так часто используются вместе.

> Arc<Mutex\<User>> можно читать как User с эксклюзивным мутабельным доступом и счётчиком ссылок.

# **Arc<Mutex\<T>>**

Используя их вместе мы:
- Обеспечиваем эксклюзивный мутабельный доступ к объекту только одним потоком, за это отвечает `Mutex`.
- Обеспечиваем, что объект будет очищен в нужный момент - ровно тогда, когда в нём не останется никакой необходимости, то есть на него не останется ссылок - за это отвечает `Arc`.

Удалить что-то сразу после того как в объекте не осталось необходимости на самом деле важно, потому что от этого часто зависит **среднее** количество потребляемой программой **оперативной памяти**.

Работая вместе, они представляют возможность для любой структуры быть изменённой из нескольких потоков, при этом гарантировать чтобы она не была удалена раньше, чем последняя ссылка на неё перестанет существовать, а также будет сразу удалена, как только эта ссылка перестанет существовать.